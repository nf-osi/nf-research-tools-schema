{
  "pmid": "39521772",
  "abstract": "Petri nets are commonly applied in modeling biological systems. However, construction of a Petri net model for complex biological systems is often time consuming, and requires expertise in the research area, limiting their application. To address this challenge, we developed GINtoSPN, an R package that automates the conversion of multi-omics molecular interaction network extracted from the Global Integrative Network (GIN) into Petri nets in GraphML format. These GraphML files can be directly used for Signaling Petri Net (SPN) simulation. To demonstrate the utility of this tool, we built a Petri net model for neurofibromatosis type I. Simulation of NF1 gene knockout, compared to normal skin fibroblast cells, revealed persistent accumulation of Ras-GTPs as expected. Additionally, we identified several other genes substantially affected by the loss of NF1's function, exhibiting individual-specific variability. These results highlight the effectiveness of GINtoSPN in streamlining the modeling and simulation of complex biological systems.",
  "methods": "Methods Basic concepts of Petri nets Petri nets are a mathematical tool used to model and simulate the behaviors of systems. Typical Petri nets consisted of places, transitions, and arcs. Places are often presented as circles (Fig.  5a ), which usually refer to entities that participate in a process. Transitions are depicted as rectangles or bars (Fig.  5a ), representing events or processes. Arcs are directed arrows that connect places and transitions (Fig.  5a ). Places often hold tokens, which are illustrated as dots, representing the states of the system or the amount of the signals (Fig.  5a ). Formally, a Petri net is defined as a four-tuple: where 1 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\rm {PN}}}= \\langle P,T,I,O \\rangle$$\\end{document} PN = ⟨ P , T , I , O ⟩ Fig. 5 Introductions to Petri nets, mEPN, and GINtoSPN conversion. A  Basic components of a Petri net.  B  A simple demonstration of how firing a transition affects token distribution in a marked Petri net.  C  Components of mEPN notations and an example network. The example illustrates an integrated network of transcription factor bindings, RNA transcriptions, protein translations, protein complex formations, and metabolite reactions.  D  The conversion of GIN components to mEPN. Intermediate nodes of GIN may be converted to transition nodes of “Binding” or “Catalysis”, depending on the products of the reactions. Arrows with dashed lines indicate new transition nodes introduced into the network by the types of upstream and downstream nodes. For instance, a “Transcription” node is generated if the edge connects a “DNA region” and an “RNA” node.  E  The example network corresponding to  B  in GIN style. The network shows the translation of transcription factor G1’s RNA into protein, which binds to the DNA regions of G2 and G3, promoting the transcription of their RNAs. The proteins translated from these RNAs form a G2_G3 complex that catalyzes the conversion of Metabolite 1 into Metabolite 2. P  = { p 1 ,  p 2 , …  p } is a finite set of places. m T  = { t 1 ,  t 2 , …  t } is a finite set of transitions. n I  = { i 1 ,  i 2 , …  i } is a finite set of input arcs, whose starting and ending nodes  k u  and  v  follow:  u \n \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\,\\in$$\\end{document} ∈ P  and  v \n \n \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\in$$\\end{document} ∈ T . O  = { o 1 ,  o 2 , …,  o l } is a finite set of output arcs, where  u \n \n \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\in$$\\end{document} ∈ T  and  v \n \n \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\in$$\\end{document} ∈ P . Petri nets are bipartite graphs, meaning places must connect to transitions, and transitions must connect to places (Fig.  5B ). The distribution of tokens across places is referred to as the “marking”. Tokens can move between places according to the rules of “firing” (Fig.  5B ). The firing of a transition represents the occurrence of an event, while the movement of tokens represents state changes. For instance, in Fig.  5B , before firing, place P1 holds two tokens while P2 has none. After firing, one token is removed from P1 and transferred to P2 via transition T1. Using this simple logic, we can model complex biological systems with Petri nets and simulate the flow of tokens, representing quantities like molecule counts or signal intensities. The mEPN style and signaling Petri net simulation To perform an SPN simulation, we first need to construct a Petri net model in Edinburgh Pathway Notation (mEPN) style. mEPN is a framework that represents various molecular components (places) and their interactions (transitions). Commonly used notations for places include DNA, RNA, proteins, protein complexes, and metabolites, while transitions include token input, binding, catalysis, transcription, and translation (Fig.  5C ). For example, Fig.  5C  illustrates an mEPN-styled Petri net involving three genes and two metabolites. “G1” represents gene 1, a transcription factor that binds to the promoter regions of G2 and G3, promoting the transcription of their mRNAs. After translation into proteins, the proteins from G2 and G3 form a complex that catalyzes the conversion of Metabolite 1 into Metabolite 2. It is important to note that token input is classified as a transition, with the number of input tokens indicated as the weight of the arc connecting the token input transition to the G1.RNA node. After constructing a Petri net model in mEPN style, we can export the model in GraphML format and perform SPN simulation in Biolayout Express3D. A key feature of SPN is that it does not require the construction of equations or the specification of rate constants for model parameterization; instead, it relies primarily on the structure of the network. Parameterization is achieved through the distribution of tokens across the entity nodes. A single run of an SPN model consists of a series of time blocks, during which each transition is fired exactly once in a random order. In this work, we executed the simulation for 500 runs, averaging the results of a single entity node across these runs for each time block. A formal description of SPN simulation can be found in Ruths et al.  . 6 Construction of a Petri net model in mEPN style using user-defined gene/chemical list There are two major steps in constructing an mEPN-style Petri net model using GINtoSPN. The first step involves extracting molecular interactions from GINv2 and building a directed topological sub-graph. Because most genes and chemicals are separated by “intermediate” nodes in GIN, the input genes and chemicals are used as “seeds” for expanding the node collection to create a proper topological structure. The strategies for collecting nodes are different between signaling pathways and metabolic pathways. For signaling pathways, kinases are both enzymes and substrates/products of reactions, so genes are separated solely by intermediate nodes. A valid path is then constructed from the following nodes: 2 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${n}_{0},{n}_{0}\\in \\left\\{{{\\rm {input}}}\\right\\}$$\\end{document} n 0 , n 0 ∈ input 3 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\left\\{{n}_{1}\\right\\}={N}_{{{\\rm {out}}}}\\left({n}_{0}\\right)\\,{{\\rm {and}}}\\,{n}_{1}\\in \\left\\{{n}_{;}\\right\\}$$\\end{document} n 1 = N out n 0 and n 1 ∈ n ; where  4 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\left\\{{n}_{2}\\right\\}=N}_{{{\\rm {out}}}}\\left({n}_{1}\\right)\\,{{\\rm {and}}}\\,{n}_{2}\\in \\left\\{{{\\rm {input}}}\\right\\}$$\\end{document} n 2 = N out n 1 and n 2 ∈ input n 0  is a starting node present in the input list,  N out  is the function that retrieves all downstream nodes,  n  denotes an intermediate node (indicated by the presence of ‘;’ in their names), and {input} is the set of input node names. ; In contrast, in metabolic reactions, proteins typically serve as enzymes that catalyze the reactions. Consequently, genes are separated by both intermediate nodes and metabolite nodes. Therefore, metabolic paths are constructed from the following nodes: 5 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${n}_{0},{n}_{0}\\in \\left\\{{{\\rm {input}}}\\right\\}$$\\end{document} n 0 , n 0 ∈ input 6 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\left\\{{n}_{1}\\right\\}={N}_{{{\\rm {out}}}}\\left({n}_{0}\\right),\\,{{\\rm {and}}}\\,{n}_{1}\\in \\left\\{{n}_{;}\\right\\}$$\\end{document} n 1 = N out n 0 , and n 1 ∈ n ; 7 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\left\\{{n}_{2}\\right\\}=N}_{{{\\rm {out}}}}\\left({n}_{1}\\right),\\,{{\\rm {and}}}\\,{n}_{2}\\in \\overline{\\left\\{{{\\rm {protein}}}\\right\\}}$$\\end{document} n 2 = N out n 1 , and n 2 ∈ protein ¯ 8 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\left\\{{n}_{3}\\right\\}=N}_{{{\\rm {out}}}}\\left({n}_{2}\\right),\\,{{\\rm {and}}}\\,{n}_{3}\\in \\left\\{{n}_{;}\\right\\}\\,{{\\rm {and}}}\\,{n}_{3}\\in \\left\\{{n}_{1}\\right\\}$$\\end{document} n 3 = N out n 2 , and n 3 ∈ n ; and n 3 ∈ n 1 where  9 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\left\\{{n}_{{\\rm {s}}}\\right\\}=N}_{{{\\rm {in}}}}\\left({n}_{1}\\right),\\,{{\\rm {and}}}\\,{n}_{{\\rm {s}}}\\in \\overline{\\left\\{{{\\rm {protein}}}\\right\\}}$$\\end{document} n s = N in n 1 , and n s ∈ protein ¯  is the set of nodes that are not proteins nor intermediates (hence metabolites),  \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\overline{\\left\\{{\\rm {{protein}}}\\right\\}}$$\\end{document} protein ¯ N in  is the function that retrieves all incoming nodes, and  n s  represents a node that serves as the substrate of the reaction. The method for extracting molecular interactions from GINv2 has been compiled in the function “generate_node_collection” within our tool GINtoSPN. Specifically, the edgelist of GIN was loaded into R and was used to generate an igraph object. After extracting the nodes, a sub-graph was created using the igraph function ‘induced_subgraph’, which was then converted back into an edgelist. To integrate the interactions from the gene regulatory network, we downloaded the TF-target relations from GTRD , and searched for interactions between any TFs and target genes present in the node collections. The results were formatted into an edgelist and imported into R to be combined with the edgelist generated from the sub-graph induced from GIN. Subsequently, a new sub-graph was generated using the igraph function ‘graph_from_edgelist’. The sub-graph was adjusted for the nodes’ color and size using the function ‘adjustNode_color_size’ built-in GINtoSPN for representation (i.e. Fig.  54 , 55 2A ). The second step involves converting the igraph object of the sub-graph into mEPN style. The main conversion processes are encapsulated in a single function, “convert_graph_to_graphml”. This function requires three inputs: an igraph object extracted from GIN, a coding gene list, and a matching table of initial tokens and places. The conversion begins by initializing a list with a standard GraphML header. The function then generates a vector of nodes and an edge list based on the igraph object. The nodes in the vector are converted to GraphML format according to the following rules: Nodes included in the coding gene list are converted to places labeled “Protein” in mEPN style. Nodes containing “;” in their names, indicating that they are intermediate nodes, are converted to transitions labeled “Catalysis” (for biochemical reactions) or “Binding” (for the formation of protein complexes) in mEPN style. Nodes that are neither proteins nor intermediate nodes are converted to places labeled “Metabolite” in mEPN style (see Fig.  5D ). If DNA regions and RNAs are involved, they are converted to the corresponding components in mEPN style. Additionally, specific types of transition nodes, such as “Transcription” and “Translation,” are introduced if the tool detects edges between DNA, RNA, and protein nodes (see Fig.  5D ). An example of a network in GIN style corresponding to the network in mEPN style shown in Fig.  5C  is presented in Fig.  5E . Overall, this conversion step transforms networks like Fig.  5E  into the format illustrated in Fig.  5C . Additionally, if a list of input tokens is provided to the function, the nodes that intersect with both the input token list and the node list of the subgraph will be assigned two extra nodes: a ‘Token Input’ transition node and a ‘Degenerate’ node. The ‘Degenerate’ nodes are introduced to prevent the excessive accumulation of tokens of the molecules, as tokens are continuously generated from the ‘Token Input’ nodes. To avoid additional computation, the coordinates of the nodes are assigned random values, since the layout does not influence the results of the SPN simulation. Following these rules, the conversion of the subgraph into mEPN style involves the following steps: Generate a header for the new GraphML file. Create an edge list of the biochemical reaction network, then loop through each edge with the following actions: Check the types of the starting and ending nodes of the edge. If a node’s name is included in a precompiled protein list, it is classified as a protein node; if the name contains “;”, it is considered an intermediate node; if it includes “.DNA” or “.RNA”, it is categorized as a DNA region or RNA node, respectively. If the node does not fit any of these criteria, it is classified as a metabolite. Convert nodes to places or transitions. Based on the types of the two nodes, create new node entities in GraphML format following mEPN notations (see Fig.  5D ). The mEPN paradigm specifies settings for different types of places and transitions, including shape, width, height, color, and display text, all of which are recognized by Biolayout Express3D for SPN simulation. Convert edges to arcs. During the conversion process, arcs can be of two types: ordinary arcs and inhibitory arcs. Similar to the node conversion, create new arc entities in GraphML format according to the specific design for both types of arcs in the mEPN paradigm. Check for a list of input tokens. If provided, generate a token input transition node for each entity node (place) in the list, along with a degenerate node. Then, generate arcs to connect the token input node to the entity node with weights representing the number of input tokens. Also, it generates arcs connecting the entity node to the degenerate node. This is the only required parameterization step for SPN simulation. Finalize the GraphML file by generating an ending. Load the GraphML file into yEd and compute the layout using the “Layout” → “Hierarchical” option with default parameters. Construction of a Petri net model for neurofibroma The construction of an mEPN-style Petri net model for neurofibroma involves the following steps (in R environment): Collect the genes associated with neurofibroma. The gene list was extracted from the R object of MSigDB  C5 collection of HPO terms using the “read.GMT” function from the R package ‘ActivePathways’ 62 , 63 . 64 Generate a collection of nodes based on GINv2 topology and the neurofibroma gene list. We utilized the generate_node_collection function from our tool GINtoSPN, specifying the neurofibroma gene list, the igraph object of GINv2, and a list of all coding genes in GINv2 to create a collection of nodes. This collection was then refined using the rm_unrelatedNodes and add_parentNodes functions to remove unrelated nodes and incorporate the parent nodes of intermediate nodes. Construct an igraph object of the sub-graph. We employed the induced_subgraph and igraph::simplify functions from the igraph package to construct the igraph object for the neurofibroma network. For Fig.  2A , we adjusted the layout using the adjustNode_color_size function from GINtoSPN and the layout_with_fr function from the igraph package. Convert the igraph object of the neurofibroma molecular interaction network into a Petri net in mEPN style. Using the igraph object of the neurofibroma network and the coding gene list, we converted the igraph object into a list containing the header, nodes, edges, and ending of a GraphML file. This list was then transformed into plain text and output to a file. Compute the layout. We loaded the GraphML file into yEd, and computed the layout by using the “Layout” → “Hierarchical” option with default parameters. This Petri net model was not marked and, therefore, was not used for SPN simulation. Construction of Petri net models for neurofibromatosis type I To build Petri net models for the SPN simulation of neurofibromatosis type I (NF-1), we specifically collected and refined a gene list associated with NF-1. This gene list was utilized to construct an igraph object in R, representing the molecular interaction networks of NF-1. We then converted the igraph object into marked Petri nets based on an RNA-seq dataset. The process details are as follows: Build a gene list for NF-1. Core genes from downstream signaling pathways, specifically the PI3K/Akt and RAS/RAF/ERK pathways (see Supplementary Table  S2 ), were added to the neurofibroma gene list to create a new NF-1 gene list. Phenotypes that “very frequently” co-occur with NF-1 (ORPHA636,  https://hpo.jax.org/browse/disease/ORPHA:636 ) according to HPO, were selected, and gene lists associated with these phenotypes were used for intersection analysis. This analysis was performed using the R package “UpsetR”. Eight shared genes from the two modules were further incorporated into the NF-1 gene list, along with one chemical, CHEBI37045, which is purine-GTP. Generate a collection of nodes based on GINv2 and the NF-1 gene list. First, we used the function “generate_node_collection” from GINtoSPN to generate a collection of nodes. Then we refine the node collection by the function “rm_unrelatedNodes” and “add_parentNodes” to remove unrelated nodes and add the parent nodes of the intermediate nodes. Construct an igraph object of the sub-graph. We used the functions “induced_subgraph” and “igraph::simplify” from package “igraph” to construct an igraph object for the network of NF-1. We then added the formation paths for protein complex and new gene regulatory paths by the function “add_prcFormation_and_GRN” from GINtoSPN. Convert the igraph object of NF-1’s molecular interaction network into marked Petri nets in mEPN style. The RNA-seq results generated by  GSE113957  were used as the token input when building the marked Petri nets. The RNA-seq results were parsed into a matrix, where rows are genes and columns are human individuals. We first built the Petri net model for normal human cells by generating a list object containing the header, nodes, edges, and ending of a GraphML file. This mEPN-styled Petri net was further parameterized by incorporating the gene expression profiles. For each column of the gene expression matrix, each of the RNA nodes whose names are included in the RNA expression profiles are connected to a token input transition node and a degenerate transition node. 143 marked Petri nets in mEPN style were generated in the form of list objects by the function “convert_graph_to_graphml” from GINtoSPN. To simulate the loss of function effects of the NF1 gene, we deleted the transition nodes that were catalyzed by NF1 and all the related arcs. Similar to the normal human skin fibroblast cells, we generated 143 list objects of marked Petri nets in mEPN style for NF1 mutated conditions. All these lists were further converted to pure texts and output to a total of 286 GraphML files. Signaling Petri net simulation by Biolayout express3D The GraphML files were loaded into Biolayout express3D version 3.4 for SPN simulation. Upon loading, the software automatically recognized the mEPN-styled Petri net model and prompted for SPN simulation. The simulation parameters were as follows: Number of time blocks: 100; Number of runs: 500; SPN stochastic distribution: standard normal distribution; SPN transition type: consumptive transitions. The simulation results were then imported into R for further analysis. Nodes selected for Fig.  4C  were based on a fold change (>1.2 or <0.8) of the average tokens across the 90 time blocks in the NF1-mutated condition compared to the normal condition, in at least one individual.",
  "introduction": "",
  "results": "",
  "discussion": "",
  "fetched_at": "2026-02-11T23:37:53.931163",
  "abstract_length": 1049,
  "methods_length": 22327,
  "introduction_length": 0,
  "results_length": 0,
  "discussion_length": 0
}